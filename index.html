<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Marker Tool (constant opacity + straight)</title>
  <style>
    body { margin:0; padding:0; }
    /* Background page/content goes here (image just for example) */
    .page {
      max-width: 1000px;
      margin: 0 auto;
      display: block;
    }

    /* Canvases overlay the whole viewport */
    canvas#ink, canvas#preview {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: transparent;
      pointer-events: none; /* enabled only on ink */
    }
    canvas#ink { pointer-events: auto; }

    /* Toolbar on the top-right */
    #toolbar{
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: flex; gap: 6px;
      background: rgba(255,255,255,0.85);
      border: 1px solid #ccc; border-radius: 8px;
      padding: 6px;
      backdrop-filter: blur(6px);
    }
    #toolbar button{ cursor:pointer; }
    #toolbar button.active{
      outline: 2px solid rgba(106,163,255,0.45);
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <!-- Your page/image underneath -->

  <!-- Toolbar -->
  <div id="toolbar">
    <button data-mode="pen" class="active">Pen</button>
    <button data-mode="highlighter">Highlighter</button>
    <button data-mode="eraser">Eraser</button>
    <button id="clearBtn">Clear</button>
  </div>

  <!-- Main ink canvas + preview canvas -->
  <canvas id="ink"></canvas>
  <canvas id="preview"></canvas>

  <script>
    const ink = document.getElementById('ink');
    const prev = document.getElementById('preview');
    const ictx = ink.getContext('2d');
    const pctx = prev.getContext('2d');

    function fit() {
      [ink, prev].forEach(cv => {
        cv.width  = window.innerWidth;
        cv.height = window.innerHeight;
      });
    }
    window.addEventListener('resize', fit); fit();

    const toolbar = document.getElementById('toolbar');
    const clearBtn = document.getElementById('clearBtn');
    let mode = 'pen';
    let drawing = false;

    function setMode(m){
      mode = m;
      [...toolbar.querySelectorAll('button[data-mode]')]
        .forEach(b => b.classList.toggle('active', b.dataset.mode === m));
    }
    toolbar.addEventListener('click', e=>{
      const b = e.target.closest('button[data-mode]');
      if (b) setMode(b.dataset.mode);
    });

    clearBtn.addEventListener('click', ()=>{
      ictx.clearRect(0,0,ink.width,ink.height);
      pctx.clearRect(0,0,prev.width,prev.height);
    });

    // ---------- Pen ----------
    function penStyle(){
      ictx.globalCompositeOperation = 'source-over';
      ictx.strokeStyle = 'red';
      ictx.lineWidth = 2;
      ictx.lineCap = 'round';
      ictx.lineJoin = 'round';
    }

    // ---------- Highlighter ----------
    const HL_COLOR = 'rgba(251, 247, 25, 0.20)'; // transparency = 20%
    const HL_HEIGHT = 26;                    // band thickness = 26
    let startPt = null;

    function drawRoundRect(ctx, x, y, w, h, r=8){
      const rr = Math.min(r, Math.abs(h)/2, Math.abs(w)/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.lineTo(x+w-rr, y);
      ctx.quadraticCurveTo(x+w, y, x+w, y+rr);
      ctx.lineTo(x+w, y+h-rr);
      ctx.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
      ctx.lineTo(x+rr, y+h);
      ctx.quadraticCurveTo(x, y+h, x, y+h-rr);
      ctx.lineTo(x, y+rr);
      ctx.quadraticCurveTo(x, y, x+rr, y);
      ctx.closePath();
    }

    // ---------- Eraser ----------
    function eraserStyle(size=200){ // eraser size = 200
      ictx.globalCompositeOperation = 'destination-out';
      ictx.strokeStyle = 'rgba(0,0,0,1)';
      ictx.lineWidth = size;
      ictx.lineCap = 'round';
      ictx.lineJoin = 'round';
    }

    function getPt(e){
      const rect = ink.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    ink.addEventListener('pointerdown', e=>{
      drawing = true;

      if (mode === 'pen'){
        penStyle();
        const {x,y} = getPt(e);
        ictx.beginPath();
        ictx.moveTo(x,y);
      }
      else if (mode === 'highlighter'){
        startPt = getPt(e);
        pctx.clearRect(0,0,prev.width,prev.height);
      }
      else if (mode === 'eraser'){
        eraserStyle(200);
        const {x,y} = getPt(e);
        ictx.beginPath();
        ictx.moveTo(x,y);
      }
      ink.setPointerCapture(e.pointerId);
    });

    ink.addEventListener('pointermove', e=>{
      if (!drawing) return;

      if (mode === 'pen'){
        const {x,y} = getPt(e);
        ictx.lineTo(x,y);
        ictx.stroke();
      }
      else if (mode === 'highlighter'){
        const {x} = getPt(e);
        const x0 = Math.min(startPt.x, x);
        const w  = Math.abs(x - startPt.x);
        const y0 = startPt.y - HL_HEIGHT/2;

        pctx.clearRect(0,0,prev.width,prev.height);
        pctx.fillStyle = HL_COLOR;
        drawRoundRect(pctx, x0, y0, w, HL_HEIGHT, 6);
        pctx.fill();
      }
      else if (mode === 'eraser'){
        const {x,y} = getPt(e);
        ictx.lineTo(x,y);
        ictx.stroke();
      }
    });

    function endStroke(e){
      if (!drawing) return;
      drawing = false;

      if (mode === 'highlighter'){
        ictx.save();
        ictx.globalCompositeOperation = 'source-over';
        ictx.drawImage(prev, 0, 0);
        ictx.restore();
        pctx.clearRect(0,0,prev.width,prev.height);
      }

      ictx.beginPath();
      ink.releasePointerCapture?.(e.pointerId);
    }

    ink.addEventListener('pointerup', endStroke);
    ink.addEventListener('pointercancel', endStroke);
    ink.addEventListener('pointerout', endStroke);
  </script>
</body>
</html>
